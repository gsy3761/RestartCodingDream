# c数组和指针规范

### 数组

- 型式 数组名称 [数组数量]

- 数组一旦创建，那么无法再次被改变大小

  - 数组在内存中是依次排开的
  - 赋值号左边的叫做左值，右边的叫做右值
  - 数组不是c语言独有的，在fortran里面也有，但是fortran不是从0开始的，因为从0开始标号对于 编译器会简单很多，之后的c-like语言都是数组从0开始标号的

- 数组的初始化

  - 可以使用 

    ```c
    array_init[可以没有数字]={[1]=4,2,3,[12]=4}
    //如此初始化的数组是0，4，2，3，0，0，0，0，0，0，0，4
    ```

  - 对于数组大小的判定

    - 使用sizeof

      - 数组大小

        ```c
        数组大小=sizeof(array)/sizeof(array[0]);
        ```

      - 数组本身不能够被直接复制过去，本质是一个const的东西

      - 在数组初始化的时候，比如int array_ini={1，2，3，}，在最后可以加上一个逗号，可以拿来装一装，这是一个70/80年代一个口耳相传的传统，也方便了后面的人加入东西。这最后加的一个逗号不会影响编译

    - 注意在数组传入函数的时候，往往需要再定义一个用于表示数组长度的变量，因为在函数中是无法使用sizeof来判定出数组的长度的，需要在函数外判断出数组的长度并作为参数传入函数中（和指针有关）

      - 因为传进去之后这一个数组变成了一个指针，所以大小在函数中变成了一个指针的大小，数组变量是特殊的指针，数组本身表达地址
      - 数组变量是const指针，不能够被赋值，这也是数组之间是不能赋值的原因
      - int a[]=int * const a;
        - 关于const和*的关系，const在\*前面表示变量值不能被更改，在之后表示指针指向的值不能被更改
        - 使用const指针能够以比较少的字节数传递值给函数，也能避免函数对外面变量的修改（即const *，非\*const）

    - 把一个数组的所有元素交给另一个数组，只能够使用遍历的方法

    - 注意：在二维数组或者多维数组中，使用array[i，j]，这么做i，j会构成一个运算表达式，得到结果j，最后结果和array[j]一致

      - 多维数组的行可以不给出，编译器会自动填充，但是列一定得给出
        - 注意：多维数组只能第一个方括号是空的

### 地址与指针

- 取地址运算&

  - 获取变量的地址，必须作用在变量上，用于取出变量的地址
  - 输出地址使用%p更准确，虽然%x也会输出同样的16进制，但是会得到一个warning
  - 取地址必须是取一个确切的地址

- 指针*

  - 保存地址的变量，取出地址上的量，就是保存地址的变量
  - 注意：int* p，q；是把星号加给了p不是给q，本质是p指针和q的int类型变量；不管星号是靠近int还是靠近p，意思是一样的
    - 是\*p是一个int，不是int* 是p
    - p应该是之后用来指向一个变量的指针，值是一个地址
    - *p是这个地址取出的值
  - 指针变量存有的是实际值的变量的地址
  - 向函数内传入指针，就能够在函数内控制外面的变量
  - *是一个单目运算符，用来访问指针的值所表示的地址上的变量

- 关于左值

  - 是值不是变量
  - 因为出现在赋值号左边的不是变量，是表达式计算的结果，是值

- 什么时候非用指针

  - 

    ```c
    //在函数的时候交换两个值
    引用的时候：swap（&a，&b）；
    定义的时候：swap（*a，*b）；
    
    ```

- 指针运算

  - 指针+1，是指向（指针原地址+1*指针指向的元素大小）的地址
  - 可以使用+，+=，-，-=，不能乘除

- 指针的比较

  - 就是地址大小的比较

- *p++

  - ++优先级高，但是 是用完p之后进行+一个模具大小的内存空间

- 0地址

  - 是一个不能随便碰的地址，所以指针不应该具有0值
    - 但是可以使用0地址来表示返回的指针是无效的
    - 或者指针没有被真正的初始化

- NULL（必须全部大写，小写不管用）

  - 是一个被预定义的符号，表示0地址，因为有的编译器不愿意用0来表示0地址
  - 想要使用0地址的时候，建议不使用0，而是使用NULL

- 指针的类型

  - 无论指向什么类型，所有的指针的大小都是一样的，因为都是地址
    - 但是只想不同类型的指针是不能直接互相赋值的，是为了避免用错指针

- 指针的类型转换 

  - 对于小白没什么意义，但是很多时候不得不做这个

  - void*表示不知道指向什么东西的指针

    - 计算的时候和char*相同，但是不相通

  - 指针也可以转换类型

    - ```c
      int *p = &i;
      void *q = (void*) p;
      ```

- 指针的用途

  - 传入较大的数据的时候用作参数

  - 传入数组之后对数组进行操作

  - 函数需要返回不止一个结果的时候

  - 需要用函数修改不止一个变量

  - 动态申请内存

    - 在C99之前有ANSI标准，不支持以变量的形式输入数组个数

    - 使用malloc需要使用头文件stdlib.h

    - 返回的是void*，所以大多时候需要强制类型转换

    - ```c
      c99: int array_a[10];
      ANSI / C99: array_a = (int*)malloc(number*sizeof(int))
      ```

      - 之后拿array_a当数组用就可以 
      - 一旦用malloc得到了一块空间交给了array_a，之后对array_a的操作完全可以当作数组用，本质就是一个数组
        - 这就是使用malloc数组分配可变的空间分配

    - 还内存

      - ```c
        free(array_a);
        ```

      - 注意：只能通过还申请来的空间的首地址来还地址

    - 向malloc申请的空间的大小是以字节为单位的，返回的结果是void*，需要类型转换为自己需要的类型

      - malloc只是用来要空间
      - 如果空间被用完了，malloc申请失败会返回0或者NULL
      - 系统最大给的空间根据不同的操作系统是不一样的  

    - free

      - 如果free（NULL）能够运行，只是它什么都不做
      - free（NULL）对于写指针程序是一个好习惯，因为一个指针被定义的时候为NULL，到时候释放的时候释放的其实就是NULL，由于某些原因没有malloc，或者malloc得到一个失败的结果，指针就是NULL，所以为了配合这个好习惯，所以free（0）是不会出错的，free（1）之类的会是错误的

    - 常见的问题

      - 申请了没有free会导致长时间运行内存逐渐下降
        - 对于小程序是无所谓的，malloc即使没有free，当程序运行结束的时候，os会释放这个程序使用过的所有内存
        - 这是一个坏习惯，程序申请的内存是有限的，写大程序会出大问题
        - 对于新手来说，是忘记free；对于不够高的高手来说，是找不到合适的时机和地方做free这件事情，是代码结构问题
      - free过的内存再free了一次，如果地址变过了，直接去free会报错
      - 解决方法
        - 牢牢记住free，有一个malloc就写一个free牢牢配对
        - 对程序的整体架构有良好的设计，保证程序有良好的时机去free
        - 有经验，多阅读别人的代码，写自己的代码，在实践中失败并且总结经验

### 字符数组

- 注意字符串和字符数组的区别，在字符数组的末尾加上'\0'就是字符串

  - 区别在于最后的'\0'

    - 这个表示的就是整数值的0
    - 注意和‘0’不同，这是一个字符，这个字符的大小是ascii的0，是人可以读到的，本质是0x30，即十进制的48
    - '0'标志着字符串的结束，所以在计算字符串多少的时候是不会作为+1的长度计算进去的 
    - 字符串在内存中一定是以数组的形式存在，可以以数组或者指针的形式访问，更多的是以指针的形式 

  - 字符串处理的函数放在string.h里面

  - 字符串是变量，长度是所有看到的字符大小+1（‘\0‘）

    ```c
    char *str = “Hello”;//名字叫str的指针指向一个字符数组，字符数组中放的内容是hello
    char str[] = "Hello";//字符数组里有hello
    char str[10] = "Hello";//十个字节大的str数组，往里面放了hello（占据6个字节） 
    ```

  - 两个相邻的字符串常量会被自动连接起来

    - c语言会把两个相邻的字符串，中间没有其他的符号，会将两个字符串连接起来变成一个大的字符串

  - 字符串是字符数组的形式存在，不能使用运算符对字符串做运算，通过数组的方式可以遍历数组

    - 后来的语言如java，python，php等对字符串进行了运算符重载之类的，比如可以使用+把两个字符柴连接起来
    - 但是c语言出现在计算机拿来做数字运算，不是80年代之后的信息处理，两个年代最大的不同是处理的是什么东西，70年处理的是数字，80年之后是处理文字的能力

  - 对于c唯一特殊的地方是字符串字面量可以用来初始化字符数组

- 字符串变量

  - 有两种形式（上面的typera代码段）
  - 通过看指针指向的字符串和变量可以发现
    - 指向的变量的地址很大
    - 指向字符串的地址很小
    - 因为字符串存放在代码段，地址很小，是只读的，如果对这个进行了写入，操作系统会产生保护，让程序崩溃；如果写入了，那就是操作系统不够好，没有起到保护的责任
    - 因为直接赋值的这个上文的“Hello World”字符串是在编译的时候就已经有值的一个东西，所以编译器会放在只能读不能写的地方
    - 如果程序中有两处相同的这个字符串，两个指针会指向同一个地方，必须是只读的，不然更改了一个指针，那么其他的指针很难知道怎么改变
    - 实际上，这个字符串的指针，初始化为指向一个字符串常量，由于这个常量所在的地方，实际上是const char *指针名，但是因为历史的原因，编译器接受不带const的写法
      - 试图对s所指的字符串做写入会导致严重的后果
    - 如果需要修改字符串，应该使用数组，char str[] = “hello world”；
  - 两种情况分类
    - 使用数组：这个字符串可以进行更改
      - 作为本地变量空间自动被回收
    - 使用指针：这个字符串事前不知道在哪，不可被更改
      - 用于处理函数参数，数组作为函数参数，和数组是一样的，因为进来的就是指针
      - 用于动态分配空间，字符的空间是用malloc得到的，那么使用指针
    - 总结
      - 如果要构造一个字符串，那么使用数组
      - 如果要处理一个字符串，那么使用指针

- 字符串的输入输出

  - c语言对于字符串的处理能力不足

  - 字符串的输入

    - %s是以空格，tab，回车为断开的

      - 但是，scanf是不安全的，因为他不知道要读进去的内容的长度

      - ```c
        char string[9];//其实最后还有一个0，所以只能接受8个
        scanf("%s",string)；//scanf不知道读进去的长度，会越界
         // 安全的方式是使用%7s之类的，相当于和scanf说了最多读7个（不包括0），后面的部分交给下一个scnaf阅读
        ```

    - 常见错误

      - 指针没有初始化，在使用指针的时候一定要确保指针已经初始化了。当我们不知道给指针变量初始化什么的时候我们一般初始化为**NULL**，这边的NULL指针是一个特殊的指针变量，不指向任何内存，用来表示这个指针目前未指向任何位置。所以对NULL指针进行解引用操作是非法的，**对指针进行解引用之前，要确定它不是NULL指针**

        - 应该如此

          ```c
          int  *a = NULL;
              int b = 1;
              a = &b;
          ```

    - 空字符串

      - “”，两个连在一块的双引号，数组的长度是1，表示空字符串

    - 字符串指针

      - char **a；
        - a是一个指针，指向另一个指针，那个指针指向一个字符或 字符串

    - main函数的参数

      ```c
      int main（int argc，char const *argv[]）；
      ```

      - c语言的数组没法自己告诉自己多大，整型参数argc用于告知argv数组多大
      - 其中的argc和argv都不是固定的，可以改为a，b之类的
      - argv是用于存放指令的，其中的const最好有，最后输出是操作系统对这个可执行文件执行的指令们
      - 因为在unix中，可以给文件取别名，所以知道是通过什么样的方法运行程序的
        - 所以argv的[0]是输入的可执行程序的名字

  - 单字符输入输出

    - putchar
      - int putchar （int c）；
      - 输出一个字符
      - 它的参数输入是int类型不是char类型，但是int能够接受的只是一个字符
        - 不是一次能够接受4个字符
        - 返回值是int，表示输出几个字符
          - 一般来说都是返回1，但是如果出现输出不能用了，那么会返回EOF，end of file，在c语言中定义为一个宏，值是-1，表示不能输出东西了，表示写失败
        - 一般不用检查putchar的输出和返回
    - getchar
      - int getchar（void）；
        - 从标准输入读入一个字符
      - 返回类型是int是为了返回EOF
        - 为什么返回int不是char，因为EOF是-1
      - ctrl+C 强制程序结束
        - shell直接关闭程序
      - ctrl+D 表示EOF的状态（macOS，unix）
        - 注意都是shell得到EOF的意思
      - ctrl+Z 表示EOF的状态（windows）
      - getchar不会我们输入一个字它蹦出一个字
        - 因为用户的键盘输入后，到的是shell，shell是行编辑，获取回车之后，shell再把这一行内容给程序，程序执行之后把结果给shell，shell再给屏幕
      - getchar和scanf都是在shell给的缓冲区里读东西，用户的输入其实就是往shell中填入东西

  - 字符串函数（标准库中的函数）（string.h）

    - strlen

      - length，知道字符串长度，不包括结尾的0
      - size_t strlen (const char *s)
        - const用于不修改传入的数组

    - strcmp

      - int strcmp(const char *s1,const char *s2)
      - 0: s1==s2
      - 1: s1>s2
      - -1: s1<s2
      - int返回的值是两个数组第一个出现不同的时候，这个字符ascii相差的大小
      - 带n的版本
        - int strncmp(const char *s1,const char *s2, size_t n);
        - 比较前n个字符，无所谓安全的版本

    - strcpy

      - char *strcpy(char *restrict dst,const char *restrict src);

        - strcpy*是为了方便这个运算结果给其他的用

      - 把 src（源）的字符串拷贝到dst（目的），restrict表明src和dst内存不重叠

      - 返回dst （目的）

      - 这是一个被深度优化的函数，至关重要，被多核心优化过，用多核心写入，这样必须防止内存重叠

      - ```c
        char *dst = (char*)malloc(strlen(src)+1);//+1是因为有0，空间需要+1
        strcpy(dst,src);
        ```

      - 安全版本

        - char *strncpy（char *restrict dest， const char *restrict src， size_t  n）；
        - 表示可以拷贝多少个

    - strcat

      - char *strcat(char *restrict s1,const char *restrict s2);
      - 讲s2拷贝到s1后面，连接成为一个长的字符串
      - 返回s1
      - s1要有足够的空间
      - 安全版本
        - char *strncat(char *restrict s1,const char *restrict s2, size_t n);

    - strchr

      - 字符串搜索函数
      - char *strchr（const char *s， int c）；
      - 从左往右搜索c第一次出现的位置，返回的是指针

    - strrchr

      - 字符串搜索函数
      - char *strrchr（const char *s，int c）；
      - 从右往左搜索c第一次出现的位置，返回的是指针，指向第一次出现c的位置
      - 小技巧
        - 如果想要求之前的函数，可以通过给指针赋0的方式，将之前的这个字符串切断（使用0切断，之后也可以使用之前设置的临时指针用来恢复）

    - strstr

      - 用于在字符串中寻找字符串
      - char *strstr（const char *s1，const char *s2）；

    - strcasestr

      - char *strcasestr（const char *s1， const char *s2）；
      - 用于查找一个字符串中的另一个小字符串的，但是寻找的过程中是忽略大小写的