# c的 featherS

### 枚举

- 程序中出现数字，尽可能使用符号来表达数字，这样子就给这些数字赋予了意义

- 可以使用枚举而不是定义独立的const 变量

- 是一种用户定义的数据类型，用关键字enum来申明

  - enum 枚举类型名字 {名字0，名字1，......，名字n}；

    - 枚举类型的名字不真的使用，要用在大括号里的名字，本身就是int类型的常量符号，值依次从0到n

    - 需要一些可以排列起来的常量值时，定义枚举就是给了这些常量值以名字

    - ```c
      void FUNC(enum color c);
      enum color t = red；
      ```

    - 实际上c语言内部，enum就是int，可以作为int直接输入输出

  - 小套路

    - 在所有的enum枚举类型之后放一个numberofxxx用于表示有多少个枚举量

    - ```c
      enum color{red，green，blue = 5}；
      ```

- 虽然枚举类型可以当作类型用，但是实际上不好用；使用枚举的主要理由是因为需要定义排比的符号量，用枚举比const int更加方便

- 枚举比宏（macro）要更好，因为枚举有int类型

- 很多语言都有枚举，但是其他语言大多比c做的好

- 自定义数据类型

  - typedef

    - 声明一个已经有的数据类型的新名字
      - typedef int Length；//Length成为int的别名
      - Length可以代替int出现在变量定义和参数声明的地方
        - Length numbers[10];

  - 改善了程序的可读性

    - ```c
      typedef long int64_t;
      typedef struct Adate 
      {
      	int month;
      	int day;
      }Date;//使用Date来代替struct Adate
      int64_t i = 10000；
      Date d = [9， 1，]；//简化了复杂的名字
      
      ```

    - typedef就是把typedef到最后一个单词之间的东西全部命名为最后一个单词

### 全局变量

- 定义在函数外面的变量
- 具有全局的生存期和作用域
  - 和任何函数无关
  - 在任何函数内部都可以使用
  - 没有做初始化的全局变量，编译器会自动给他补0，但是本地变量不会，没有初始化会得到乱七八糟的内存里的结果
- TIps
  - 使用\__func__能够输出现在所在函数的名称
- 只能使用编译的时候已知的值来初始化全局变量，因为他们的初始化发生在main函数之前
- 全局变量不能够使用变量赋值，但是可以使用const修饰的变量进行赋值
  - 不建议用其他的全局变量来初始化其他的全局变量
- 如果函数中有和全局变量同名的变量，那么全局变量被隐藏

### 静态本地变量

- 在本地变量定义的时候使用static修饰，成为静态本地变量
- 当函数离开的时候，静态本地变量会继续存在且保存值
- 静态本地变量的初始化只会在第一次进入这个函数的时候做，以后进入函数的时候会保持上一次离开的值
- 静态本地变量实际是全局变量（可以通过指针看到静态本地变量和全局变量都在代码区，实际就是全局变量，生存期和全局变量一样，只是他被放在函数里）
  - 全局变量是全局生存期，全局作用域
  - 静态本地变量是全局生存期，本地作用域

### 返回指针的函数

- 返回函数的本地变量的指针是危险的
  - 因为函数结束之后，这个本地变量就不存在（不受控）了
- 建议
  - 不要使用全局变量在函数之间传递参数和结果
  - 尽量避免使用全局变量
    - 是汇编程序带来的坏习惯，因为汇编程序没有本地变量可用
    - 汇编的变量都需要程序员自己去分配
  - 使用全局变量和静态本地变量的函数是线程不安全的

### 宏定义

- 编译预处理指令

- #开头的是编译预处理指令

  - 不是c语言的成分，但是c语言的程序离不开他们

- #define用来定义一个宏

  - 在c99之前，不能使用const，所以把有意义的常量只能使用define来定义

- 编译过程中的临时文件

  - gcc 文件名(.c)  --save-temps
    - 从.c->.i->.s->.0->a.out
      - .c是源代码经过编译预处理得到了中间编译预处理之后的中间结果文件，就是把预处理全部做完
      - .i才是真正c编译器进行编译，得到汇编代码文件.s
        - 可以使用tail .i文件名得到文件后几行的查看
      - 汇编代码文件进行汇编得到目标代码文件.o
      - 目标代码经过链接得到可执行的文件

- 注意define语句之后不用加分号，因为他不是c的语句

- 一个宏的值中有其他宏的名字，会被替换掉

- 如果一个宏的值超过一行，最后一行之前的行末要加\

  - ```c
    #define PRINT_ printf("%d",number_a);\
    							 printf("%d",number_b);
    ```

    

- 宏的值后面出现的注释不会被当作宏的值的一部分

- 没有值的宏

  - #define _DEBUG
  - 告诉编译器有这个宏，但是不需要他有什么值
  - 用于做条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了
  - 可能后面检查这个宏存在不，存在或不存在用于编译不同的代码

- 预先定义的宏（前后都有两个下划线）

  ```c
  __LINE__//这一行源代码当前所在的行号
  __FILE__//源代码文件的文件名
  __DATE__//源代码编译的日期
  __TIME__//源代码编译的时间
  __STDC__//编译器将按照ANSIC标准来编译c程序
  ```

  ### 带有参数的宏

  - 像函数的宏
  - #define cube（x） （（x）*（x））
    - 和c函数不同的是x没有类型
    - 比如cube（5）会被替换成为（（5）*（5））
  -  原则
    - 一切都要括号
    - 整个值要括号
    - 参数出现的每一个地方都要括号
      - 不然容易因为编译器和人脑对数据处理不一致导致的错误
  - 带参数的宏的运行效率比函数高，但是代码展开比较大，是牺牲空间换效率的
    - 宏可以做的非常复杂
      - ##表示链接，是两个#号，x##y表示x连接y，比如123##456就是123456，##左右符号必须能够组成一个有意义的符号
      - #@表示字符化操作符
      - #字符串化操作符
    - 存在东西方文化差异
      - 中国人用的少，西方人用的很多
      - 有一个缺点：没有参数类型检查
      - 如果存在类型使用问题没有检查
    - 在c++中，有inline机制，是函数但是没有函数调用的额外开销，用于替代部分宏
      - 会进行参数类型的检查
  - 其他编译预处理指令
    - 条件编译
    - error之类（大程序会用）

### 多个源代码文件（大工程）

- 多个.c文件
- main（）里面的代码太长了分成几个函数
  - 一个源代码文件太长了适合分成几个文件
  - 两个独立的源代码文件不能编译形成可执行程序
- 出现的[error]ld returned 1 exit status中的ld是链接器
  - 这个意思是编译没有完成，没有产生可执行文件，错误不是看这个的，这个只是表示编译出错了
- 需要新建一个项目把他们连接在一起，把不同的文件放在一个项目里
  - 把源代码文件加入进去之后，一个项目会对应产生一个可执行文件，会把一个项目中所有的源文件都编译之后，链接起来
  - 有的IDE有分开的编译和构建两个按钮，编译是对单个源代码文件编译，构建是对整个项目做链接
  - devc++是一个特殊的IDE，它允许单个文件直接写，允许不建项目；比如visual studio哪怕写单个文件也需要首先创建一个项目
- 编译单元（从编译器的角度看）
  - 一个.c文件是一个编译单元
  - 编译器同一时间每一次编译只处理一个编译单元
    - 编译完之后形成.o文件
    - compile形成.o；build把.o链接起来形成一个可执行文件；devc++没有分开，只有一个

### 头文件

-  c语言会去猜测没有被定义的函数的返回值是int类型的

-  把函数原型放在一个头文件.h中，在需要调用这个函数的源代码文件.c文件中，#include这个头文件，就能让编译器在编译的时候知道函数的原型

  ```c
  #include"xxx.h"
  ```

- #include

  - 是一个编译预处理指令，和宏一样，在编译之前就已经处理了
  - 把include的文件原封不动的插入到它所在的地方
    - 不是一定要在.c文件的最前面#Include
  - #include的两种<>和“”形式指出要插入的文件
    - “”要求编译器首先在当前目录（.c所在的目录）寻找这个文件，如果没有，那么到编译器制定的目录去寻找
    - <>让编译器只在制定的目录寻找
      - 对于unix来说，在usr/include
      - 对于windows，大概率在minGW里
    - 所以自己写的头文件使用“”，<>使用系统的
  - 环境变量和编译器命令行参数也可以指定寻找头文件的目录
  - #include误区
    - #Include不是用来引入库的
      - 他只是把include的部分原封不动的放进来
    - 比如stdio.h里面只有printf的原型，printf的代码在另外的地方，比如某个.lib（windows）或.a（Unix）中
  - 现在的c语言编译器会默认引入所有的标准库
  - #include<stdio.h>只是为了让编译器知道printf函数的原型，保证调用的时候给出的参数值是正确的类型
  - 在使用和定义这个函数的地方都应该#include这个头文件
    - 一般的做法就是，任何的.c（除了main）都有一个同名的.h。把所有对外公开的原型和全局变量的声明都放进去
  - 不对外公开的函数
    - 在函数前面加上static就能够让她成为只能在所在的编译单元中被使用的恶函数
    - 在全局变量前面加上static让它成为只能在所在的编译单元中被使用的全局变量

### 声明

- int i；是变量的定义

- extern int i；是变量的声明，不能够赋值

- 声明是不产生代码的东西

  - 函数原型
  - 变量声明
  - 结构声明
  - 宏声明
  - 枚举声明
  - 类型声明
  - inline函数

- 定义是产生代码的东西

- 重复声明

  - 同一个编译单元里面，同名的结构不能被重复声明

  - 如果头文件里面有结构的声明，很难这个头文件不会在一个编译单元里面被#include多次

  - 所以需要标准头文件结构

    - ```c
      #ifndef 宏
      #define 宏
      coding...（可能被重复定义的部分）
      
      #endif 
      可以写其他的，但是不建议 
      ```

    - 已经定义这个宏的话，那么不定义这个宏；如果没有定义过这个宏的话，那么定义这个宏

      - 运用条件编译和宏，保证这个头文件在一个编译单元中只会被#include一次
      - #pragma once也能起到相同的作用，但是不是所有的编译器都支持，这是visualstudio的，gcc不支持，用ifdefine更合适

### 格式化的输入输出

- printf

  ```c
  %[flags][width][.prec][hlL]type
    
  flag
    - 左对齐
    + 在前面放 + 或者 -
    （space） 正数留空
    0 用0填充
    
  width 或 prec（number表示应该写入的想要的数字）
    number 最小字符数
    * 下一个参数是字符数
    .number 小数点后的位数
    .* 下一个参数是小数点后的位数
    
  hlL修饰类型
    hh 单个字节
    h short
    l long
    ll long long
    L long double
    
  type
  ```

![截屏2022-01-04 下午2.20.25](https://tva1.sinaimg.cn/large/008i3skNly1gy1mabp4jcj31e40u0jtv.jpg)

- 返回值是输出的字符数

- scanf

  ```c
  %[flag]type
  ```

  ![截屏2022-01-04 下午3.10.47](https://tva1.sinaimg.cn/large/008i3skNly1gy1nqkyp0ij31dy0tkgna.jpg)

  - 返回值是读入的项目数
  - 在要求严格的程序中，应该判断每一次调用scanf或者printf的返回值，从而了解程序运行中是否存在问题
    - 比如那种一运行好几天的程序

### futures

- printf是从右往左压栈的