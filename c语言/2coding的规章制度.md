# coding的规章制度

## 语言规范

- 在c语言中，换行不意味着任何事情

- 输入以行为单位，在没有回车键之前，输入的东西是不会被传入的

- 对变量定义之后，形式无法再被改变

- scanf：f是format

- 注意double
  - double的输入是%lf，double的输出是%f
  
- 运算符：进行运算的动作
  - 优先度
    - 1>2>3>4
    - 4. “=”自右向左
    - 3. “+”，“-”自左向右
    - 2. “%”，“/”，“*“自左向右
    - 1. ”+的单目运算“，”-的单目运算（取负）“自右向左
  
- 算子：参与运算的值

- 复合赋值

  - 之前对应PDP11机的指令，因此存在
  - 如：+=，-=；*=，/=（优先级放最后）
  - 如：++，--
    - 前缀表达式
      - ++a，--a是前缀表达式，是a+1之后的结果，表达式的值是a+1

    - 后缀表达式
      - a++是后缀表达式，是a用完之后再+1，表达式的值是a

    - PDP11的历史
      - INC指令是递增，DEC指令是递减，所以c语言编译器能够很好的编译成指令，能加快
      - 但是现在没有太大意义，现在也能产生指令，现在有些CPU没有INC和DEC指令，没法加快，现在使用是因为简便

- 判断

  - if判断

    - 只要判定的不是0，其他全都执行（包括-1）

    - 关系运算的结果只有两种情况
      - 情况成立结果就是1
      - 情况不成立结果就是0

  - 6种关系（比较）运算符

    - ==；>=；<=；!=；<；>
    - 优先级低于算数符和复合运算符
    - 其中的“==”和“！=”优先度最低

  - 对于5>4>3

    - 是从左往右进行的
    - 5>4成立，所以是1；1<3所以这一条算式的最后结果是0

  - 级联的if...else

    - 一般的if...else是不连在一起的，但是过去屏幕比较小，要求对齐，因此使用else if连在一起这种形式

  - 建议使用单一出口

    - 也就是不要在ifelse循环里面打印太多东西，而应该在ifelse里面进行赋值，出循环之后再进行打印

  - 多路分支

    - switch...case...分支

    - ```c
      switch(必须int类型)
      {
      	case 1（必须是常量）:
      					;
      					;
          			break;//可以不配
      	case 2:
      					;
      					;
          			break;
      	default :
      					;
      }
      ```

- 循环(可以嵌套)

  - while循环

  - do...while循环

    - ```c
      do
      {
      	;
      }while( );
      ```

  - for循环

- 结束循环

  - break；跳出循环

  - continue；结束本次循环

  - goto 变量名；将程序的执行跳转到“变量名：”的部分

    - 不要太害怕使用goto语句，没有教科书上讲的那么恐怖

    - ```c
      goto falg1;
      			;
      			;
      flag1:
      			;
      ```

      


- sizeof运算符
  - 测量出类型在内存中占据的字节数
  - 静态运算符，结果在编译的时候决定了，在sizeof括号中做的运算不会做，比如a++，sizeof里不会+1
  - 注意，int和long的大小和编译器有关，大多为CPU的一个“字”
    - 字：CPU寄存器的大小，CPU和内存之间通过总线传输，每次传输的量，一般是64bit，或者少见的32bit
      - 一次处理64bit，也就是一个int的大小
      - int就是用来表示寄存器的





- IO
  - %e
    - 输出科学计数法
  - %E
    - 输出科学计数法，只是科学计数法由小写的e换为大写的E 
  - 带小数点的字面量是double不是float
    - 在判断两个小数是否相等的时候，要注意浮点数使用f1==f2可能会碰到很远的小数部分的不一致，使用fabs（f1-f2）<1e-12就行
    - 应该使用BCD码进行运算，比如我们的计算器使用BCD码进行运算就能够避免因为浮点数运算出现的问题
      - 曾经的一版安卓计算器就是因为使用浮点数进行的运算导致的小数部分的错误
      - 做计算器也可以使用整数去做运算
  - 碰到浮点数，直接使用double就可以了，原因同int和short
  - %c
    - 字符
- 番外
  - 逃逸字符
    - 带有\进行输出的字符
      - \b 回退一格
      - \n 换行
      - \t tab键
        - 注意：tab不是固定的大小，而是每一行的固定的位置
      - \n和\r
        - \n是换行
        - \r是回车
        - 在老式的打字机中，回车是从现在的位置回到最开头（最左边）的位置，换行是原位置的纸滚筒往下卷一行
          - 现在的shell默认\n解释为老式的回车+换行
    - 在c语言中，编译器是从上往下进行编译的
      - 所以编译器在调用这一个函数的时候，需要提前知道这一个函数是什么样子的，比如返回值是什么，有几个参数
      - 函数在main函数之前可以进行“声明”，用于让编译器知道函数原型，之后可以在main函数之后进行定义
        - 这么做就在main函数中进行调用的时候可以知道这一个函数原型是什么
          - 注意，声明中的变量名字是可以不写，或者和定义时候的变量名不一样的
        - 函数变量必须被阐述进去，其中的变量可以是
          - 字面量
          - 变量
          - 函数的返回值
          - 计算的结果
      - c语言的漏洞
        - 在函数输入参数的时候，如果函数的参数和原先定义的函数的参数不一致，这时候编译器会偷偷的把程序本身的东西转换成为函数定义的样子（类似于自动强制转换），在后续的c++和java中着一个漏洞被填补了（对于参数的形式出现的变更检查的严格）
        - 对于c语言中传递参数的“形参”和“实参”的关系，是源于世界上第一个高级编程语言-- fortran，这个概念是可以舍弃的，在那边的实参指的是在调用函数的时候实际传入的参数，形参是指在这一个函数中定义的时候参数
  - local baribales
    - 局部变量或者是本地变量
      - 是在函数内部定义的变量，每一次函数的运行都会产生一定的空间，这些变量在这个产生的空间内生存
      - 也叫自动变量，因为生存期和作用域是自动的
      - 每一个变量都有自己的生存区域，如果在自己所在之外有定义过这个变量，那么在这一个块内的变量根据在这一个块内定义的来算
    - 所以建议在编写原型的时候，一定要把参数的类型写上去，如果没有类型，那么使用void，不然编译器会去各种自己解释，有可能会出现一些问题
    - 在函数中，参数表中的（a，b）中的，不是运算符，但是参数表写成（（a，b））的格式，那么其中的，就是运算符了
    - 返回值是0，表示事情进展顺利，一切正常；当返回值是任何非0的数字，那么表示又不对劲的地方
    - bash是BA shell

### 数组

- 型式 数组名称 [数组数量]

- 数组一旦创建，那么无法再次被改变大小

  - 数组在内存中是依次排开的
  - 赋值号左边的叫做左值，右边的叫做右值
  - 数组不是c语言独有的，在fortran里面也有，但是fortran不是从0开始的，因为从0开始标号对于 编译器会简单很多，之后的c-like语言都是数组从0开始标号的

- 数组的初始化

  - 可以使用 

    ```c
    array_init[可以没有数字]={[1]=4,2,3,[12]=4}
    //如此初始化的数组是0，4，2，3，0，0，0，0，0，0，0，4
    ```

  - 对于数组大小的判定

    - 使用sizeof

      - 数组大小

        ```c
        数组大小=sizeof(array)/sizeof(array[0]);
        ```

      - 数组本身不能够被直接复制过去，本质是一个const的东西

      - 在数组初始化的时候，比如int array_ini={1，2，3，}，在最后可以加上一个逗号，可以拿来装一装，这是一个70/80年代一个口耳相传的传统，也方便了后面的人加入东西。这最后加的一个逗号不会影响编译

    - 注意在数组传入函数的时候，往往需要再定义一个用于表示数组长度的变量，因为在函数中是无法使用sizeof来判定出数组的长度的，需要在函数外判断出数组的长度并作为参数传入函数中（和指针有关）

      - 因为传进去之后这一个数组变成了一个指针，所以大小在函数中变成了一个指针的大小，数组变量是特殊的指针，数组本身表达地址
      - 数组变量是const指针，不能够被赋值，这也是数组之间是不能赋值的原因
      - int a[]=int * const a;
        - 关于const和*的关系，const在\*前面表示变量值不能被更改，在之后表示指针指向的值不能被更改
        - 使用const指针能够以比较少的字节数传递值给函数，也能避免函数对外面变量的修改（即const *，非\*const）

    - 把一个数组的所有元素交给另一个数组，只能够使用遍历的方法

    - 注意：在二维数组或者多维数组中，使用array[i，j]，这么做i，j会构成一个运算表达式，得到结果j，最后结果和array[j]一致

      - 多维数组的行可以不给出，编译器会自动填充，但是列一定得给出
        - 注意：多维数组只能第一个方括号是空的

### 地址与指针

- 取地址运算&
  - 获取变量的地址，必须作用在变量上，用于取出变量的地址
  - 输出地址使用%p更准确，虽然%x也会输出同样的16进制，但是会得到一个warning
  - 取地址必须是取一个确切的地址

- 指针*

  - 保存地址的变量，取出地址上的量，就是保存地址的变量
  - 注意：int* p，q；是把星号加给了p不是给q，本质是p指针和q的int类型变量；不管星号是靠近int还是靠近p，意思是一样的
    - 是\*p是一个int，不是int* 是p
    - p应该是之后用来指向一个变量的指针，值是一个地址
    - *p是这个地址取出的值
  - 指针变量存有的是实际值的变量的地址
  - 向函数内传入指针，就能够在函数内控制外面的变量
  - *是一个单目运算符，用来访问指针的值所表示的地址上的变量

- 关于左值

  - 是值不是变量
  - 因为出现在赋值号左边的不是变量，是表达式计算的结果，是值

- 什么时候非用指针

  - 

    ```c
    //在函数的时候交换两个值
    引用的时候：swap（&a，&b）；
    定义的时候：swap（*a，*b）；
    
    ```

- 指针运算

  - 指针+1，是指向（指针原地址+1*指针指向的元素大小）的地址
  - 可以使用+，+=，-，-=，不能乘除

- 指针的比较

  - 就是地址大小的比较

- *p++

  - ++优先级高，但是 是用完p之后进行+一个模具大小的内存空间

- 0地址

  - 是一个不能随便碰的地址，所以指针不应该具有0值
    - 但是可以使用0地址来表示返回的指针是无效的
    - 或者指针没有被真正的初始化

- NULL（必须全部大写，小写不管用）

  - 是一个被预定义的符号，表示0地址，因为有的编译器不愿意用0来表示0地址
  - 想要使用0地址的时候，建议不使用0，而是使用NULL

- 指针的类型

  - 无论指向什么类型，所有的指针的大小都是一样的，因为都是地址
    - 但是只想不同类型的指针是不能直接互相赋值的，是为了避免用错指针

- 指针的类型转换 

  - 对于小白没什么意义，但是很多时候不得不做这个

  - void*表示不知道指向什么东西的指针

    - 计算的时候和char*相同，但是不相通

  - 指针也可以转换类型

    - ```c
      int *p = &i;
      void *q = (void*) p;
      ```

- 指针的用途

  - 传入较大的数据的时候用作参数

  - 传入数组之后对数组进行操作

  - 函数需要返回不止一个结果的时候

  - 需要用函数修改不止一个变量

  - 动态申请内存

    - 在C99之前有ANSI标准，不支持以变量的形式输入数组个数

    - 使用malloc需要使用头文件stdlib.h

    - 返回的是void*，所以大多时候需要强制类型转换

    - ```c
      c99: int array_a[10];
      ANSI / C99: array_a = (int*)malloc(number*sizeof(int))
      ```

      - 之后拿array_a当数组用就可以 
      - 一旦用malloc得到了一块空间交给了array_a，之后对array_a的操作完全可以当作数组用，本质就是一个数组
        - 这就是使用malloc数组分配可变的空间分配

    - 还内存

      - ```c
        free(array_a);
        ```

      - 注意：只能通过还申请来的空间的首地址来还地址

    - 向malloc申请的空间的大小是以字节为单位的，返回的结果是void*，需要类型转换为自己需要的类型

      - malloc只是用来要空间
      - 如果空间被用完了，malloc申请失败会返回0或者NULL
      - 系统最大给的空间根据不同的操作系统是不一样的  

    - free

      - 如果free（NULL）能够运行，只是它什么都不做
      - free（NULL）对于写指针程序是一个好习惯，因为一个指针被定义的时候为NULL，到时候释放的时候释放的其实就是NULL，由于某些原因没有malloc，或者malloc得到一个失败的结果，指针就是NULL，所以为了配合这个好习惯，所以free（0）是不会出错的，free（1）之类的会是错误的

    - 常见的问题

      - 申请了没有free会导致长时间运行内存逐渐下降
        - 对于小程序是无所谓的，malloc即使没有free，当程序运行结束的时候，os会释放这个程序使用过的所有内存
        - 这是一个坏习惯，程序申请的内存是有限的，写大程序会出大问题
        - 对于新手来说，是忘记free；对于不够高的高手来说，是找不到合适的时机和地方做free这件事情，是代码结构问题
      - free过的内存再free了一次，如果地址变过了，直接去free会报错
      - 解决方法
        - 牢牢记住free，有一个malloc就写一个free牢牢配对
        - 对程序的整体架构有良好的设计，保证程序有良好的时机去free
        - 有经验，多阅读别人的代码，写自己的代码，在实践中失败并且总结经验

### 字符数组

- 注意字符串和字符数组的区别，在字符数组的末尾加上'\0'就是字符串

  - 区别在于最后的'\0'

    - 这个表示的就是整数值的0
    - 注意和‘0’不同，这是一个字符，这个字符的大小是ascii的0，是人可以读到的，本质是0x30，即十进制的48
    - '0'标志着字符串的结束，所以在计算字符串多少的时候是不会作为+1的长度计算进去的 
    - 字符串在内存中一定是以数组的形式存在，可以以数组或者指针的形式访问，更多的是以指针的形式 

  - 字符串处理的函数放在string.h里面

  - 字符串是变量，长度是所有看到的字符大小+1（‘\0‘）

    ```c
    char *str = “Hello”;//名字叫str的指针指向一个字符数组，字符数组中放的内容是hello
    char str[] = "Hello";//字符数组里有hello
    char str[10] = "Hello";//十个字节大的str数组，往里面放了hello（占据6个字节） 
    ```

  - 两个相邻的字符串常量会被自动连接起来

    - c语言会把两个相邻的字符串，中间没有其他的符号，会将两个字符串连接起来变成一个大的字符串

  - 字符串是字符数组的形式存在，不能使用运算符对字符串做运算，通过数组的方式可以遍历数组

    - 后来的语言如java，python，php等对字符串进行了运算符重载之类的，比如可以使用+把两个字符柴连接起来
    - 但是c语言出现在计算机拿来做数字运算，不是80年代之后的信息处理，两个年代最大的不同是处理的是什么东西，70年处理的是数字，80年之后是处理文字的能力

  - 对于c唯一特殊的地方是字符串字面量可以用来初始化字符数组

- 字符串变量

  - 有两种形式（上面的typera代码段）
  - 通过看指针指向的字符串和变量可以发现
    - 指向的变量的地址很大
    - 指向字符串的地址很小
    - 因为字符串存放在代码段，地址很小，是只读的，如果对这个进行了写入，操作系统会产生保护，让程序崩溃；如果写入了，那就是操作系统不够好，没有起到保护的责任
    - 因为直接赋值的这个上文的“Hello World”字符串是在编译的时候就已经有值的一个东西，所以编译器会放在只能读不能写的地方
    - 如果程序中有两处相同的这个字符串，两个指针会指向同一个地方，必须是只读的，不然更改了一个指针，那么其他的指针很难知道怎么改变
    - 实际上，这个字符串的指针，初始化为指向一个字符串常量，由于这个常量所在的地方，实际上是const char *指针名，但是因为历史的原因，编译器接受不带const的写法
      - 试图对s所指的字符串做写入会导致严重的后果
    - 如果需要修改字符串，应该使用数组，char str[] = “hello world”；
  - 两种情况分类
    - 使用数组：这个字符串可以进行更改
      - 作为本地变量空间自动被回收
    - 使用指针：这个字符串事前不知道在哪，不可被更改
      - 用于处理函数参数，数组作为函数参数，和数组是一样的，因为进来的就是指针
      - 用于动态分配空间，字符的空间是用malloc得到的，那么使用指针
    - 总结
      - 如果要构造一个字符串，那么使用数组
      - 如果要处理一个字符串，那么使用指针

- 字符串的输入输出

  - c语言对于字符串的处理能力不足

  - 字符串的输入

    - %s是以空格，tab，回车为断开的

      - 但是，scanf是不安全的，因为他不知道要读进去的内容的长度

      - ```c
        char string[9];//其实最后还有一个0，所以只能接受8个
        scanf("%s",string)；//scanf不知道读进去的长度，会越界
         // 安全的方式是使用%7s之类的，相当于和scanf说了最多读7个（不包括0），后面的部分交给下一个scnaf阅读
        ```

    - 常见错误

      - 指针没有初始化，在使用指针的时候一定要确保指针已经初始化了。当我们不知道给指针变量初始化什么的时候我们一般初始化为**NULL**，这边的NULL指针是一个特殊的指针变量，不指向任何内存，用来表示这个指针目前未指向任何位置。所以对NULL指针进行解引用操作是非法的，**对指针进行解引用之前，要确定它不是NULL指针**

        - 应该如此

          ```c
          int  *a = NULL;
              int b = 1;
              a = &b;
          ```

    - 空字符串

      - “”，两个连在一块的双引号，数组的长度是1，表示空字符串

    - 字符串指针

      - char **a；
        - a是一个指针，指向另一个指针，那个指针指向一个字符或 字符串

    - main函数的参数

      ```c
      int main（int argc，char const *argv[]）；
      ```

      - c语言的数组没法自己告诉自己多大，整型参数argc用于告知argv数组多大
      - 其中的argc和argv都不是固定的，可以改为a，b之类的
      - argv是用于存放指令的，其中的const最好有，最后输出是操作系统对这个可执行文件执行的指令们
      - 因为在unix中，可以给文件取别名，所以知道是通过什么样的方法运行程序的
        - 所以argv的[0]是输入的可执行程序的名字

  - 单字符输入输出

    - putchar
      - int putchar （int c）；
      - 输出一个字符
      - 它的参数输入是int类型不是char类型，但是int能够接受的只是一个字符
        - 不是一次能够接受4个字符
        - 返回值是int，表示输出几个字符
          - 一般来说都是返回1，但是如果出现输出不能用了，那么会返回EOF，end of file，在c语言中定义为一个宏，值是-1，表示不能输出东西了，表示写失败
        - 一般不用检查putchar的输出和返回
    - getchar
      - int getchar（void）；
        - 从标准输入读入一个字符
      - 返回类型是int是为了返回EOF
        - 为什么返回int不是char，因为EOF是-1
      - ctrl+C 强制程序结束
        - shell直接关闭程序
      - ctrl+D 表示EOF的状态（macOS，unix）
        - 注意都是shell得到EOF的意思
      - ctrl+Z 表示EOF的状态（windows）
      - getchar不会我们输入一个字它蹦出一个字
        - 因为用户的键盘输入后，到的是shell，shell是行编辑，获取回车之后，shell再把这一行内容给程序，程序执行之后把结果给shell，shell再给屏幕
      - getchar和scanf都是在shell给的缓冲区里读东西，用户的输入其实就是往shell中填入东西

  - 字符串函数（标准库中的函数）（string.h）

    - strlen
      - length，知道字符串长度，不包括结尾的0
      - size_t strlen (const char *s)
        - const用于不修改传入的数组
      - 
    - strcmp
    - strcpy
    - strcat
    - strchr
    - Strata
