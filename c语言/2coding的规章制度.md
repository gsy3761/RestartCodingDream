# coding的规章制度

## 语言规范

- 在c语言中，换行不意味着任何事情

- 输入以行为单位，在没有回车键之前，输入的东西是不会被传入的

- 对变量定义之后，形式无法再被改变

- scanf：f是format

- 注意double
  - double的输入是%lf，double的输出是%f
  
- 运算符：进行运算的动作
  - 优先度
    - 1>2>3>4
    - 4. “=”自右向左
    - 3. “+”，“-”自左向右
    - 2. “%”，“/”，“*“自左向右
    - 1. ”+的单目运算“，”-的单目运算（取负）“自右向左
  
- 算子：参与运算的值

- 复合赋值

  - 之前对应PDP11机的指令，因此存在
  - 如：+=，-=；*=，/=（优先级放最后）
  - 如：++，--
    - 前缀表达式
      - ++a，--a是前缀表达式，是a+1之后的结果，表达式的值是a+1

    - 后缀表达式
      - a++是后缀表达式，是a用完之后再+1，表达式的值是a

    - PDP11的历史
      - INC指令是递增，DEC指令是递减，所以c语言编译器能够很好的编译成指令，能加快
      - 但是现在没有太大意义，现在也能产生指令，现在有些CPU没有INC和DEC指令，没法加快，现在使用是因为简便

- 判断

  - if判断

    - 只要判定的不是0，其他全都执行（包括-1）

    - 关系运算的结果只有两种情况
      - 情况成立结果就是1
      - 情况不成立结果就是0

  - 6种关系（比较）运算符

    - ==；>=；<=；!=；<；>
    - 优先级低于算数符和复合运算符
    - 其中的“==”和“！=”优先度最低

  - 对于5>4>3

    - 是从左往右进行的
    - 5>4成立，所以是1；1<3所以这一条算式的最后结果是0

  - 级联的if...else

    - 一般的if...else是不连在一起的，但是过去屏幕比较小，要求对齐，因此使用else if连在一起这种形式

  - 建议使用单一出口

    - 也就是不要在ifelse循环里面打印太多东西，而应该在ifelse里面进行赋值，出循环之后再进行打印

  - 多路分支

    - switch...case...分支

    - ```c
      switch(必须int类型)
      {
      	case 1（必须是常量）:
      					;
      					;
          			break;//可以不配
      	case 2:
      					;
      					;
          			break;
      	default :
      					;
      }
      ```

- 循环(可以嵌套)

  - while循环

  - do...while循环

    - ```c
      do
      {
      	;
      }while( );
      ```

  - for循环

- 结束循环

  - break；跳出循环

  - continue；结束本次循环

  - goto 变量名；将程序的执行跳转到“变量名：”的部分

    - 不要太害怕使用goto语句，没有教科书上讲的那么恐怖

    - ```c
      goto falg1;
      			;
      			;
      flag1:
      			;
      ```

      


- sizeof运算符
  - 测量出类型在内存中占据的字节数
  - 静态运算符，结果在编译的时候决定了，在sizeof括号中做的运算不会做，比如a++，sizeof里不会+1
  - 注意，int和long的大小和编译器有关，大多为CPU的一个“字”
    - 字：CPU寄存器的大小，CPU和内存之间通过总线传输，每次传输的量，一般是64bit，或者少见的32bit
      - 一次处理64bit，也就是一个int的大小
      - int就是用来表示寄存器的





- IO
  - %e
    - 输出科学计数法
  - %E
    - 输出科学计数法，只是科学计数法由小写的e换为大写的E 
  - 带小数点的字面量是double不是float
    - 在判断两个小数是否相等的时候，要注意浮点数使用f1==f2可能会碰到很远的小数部分的不一致，使用fabs（f1-f2）<1e-12就行
    - 应该使用BCD码进行运算，比如我们的计算器使用BCD码进行运算就能够避免因为浮点数运算出现的问题
      - 曾经的一版安卓计算器就是因为使用浮点数进行的运算导致的小数部分的错误
      - 做计算器也可以使用整数去做运算
  - 碰到浮点数，直接使用double就可以了，原因同int和short
  - %c
    - 字符
- 番外
  - 逃逸字符
    - 带有\进行输出的字符
      - \b 回退一格
      - \n 换行
      - \t tab键
        - 注意：tab不是固定的大小，而是每一行的固定的位置
      - \n和\r
        - \n是换行
        - \r是回车
        - 在老式的打字机中，回车是从现在的位置回到最开头（最左边）的位置，换行是原位置的纸滚筒往下卷一行
          - 现在的shell默认\n解释为老式的回车+换行
    - 在c语言中，编译器是从上往下进行编译的
      - 所以编译器在调用这一个函数的时候，需要提前知道这一个函数是什么样子的，比如返回值是什么，有几个参数
      - 函数在main函数之前可以进行“声明”，用于让编译器知道函数原型，之后可以在main函数之后进行定义
        - 这么做就在main函数中进行调用的时候可以知道这一个函数原型是什么
          - 注意，声明中的变量名字是可以不写，或者和定义时候的变量名不一样的
        - 函数变量必须被阐述进去，其中的变量可以是
          - 字面量
          - 变量
          - 函数的返回值
          - 计算的结果
      - c语言的漏洞
        - 在函数输入参数的时候，如果函数的参数和原先定义的函数的参数不一致，这时候编译器会偷偷的把程序本身的东西转换成为函数定义的样子（类似于自动强制转换），在后续的c++和java中着一个漏洞被填补了（对于参数的形式出现的变更检查的严格）
        - 对于c语言中传递参数的“形参”和“实参”的关系，是源于世界上第一个高级编程语言-- fortran，这个概念是可以舍弃的，在那边的实参指的是在调用函数的时候实际传入的参数，形参是指在这一个函数中定义的时候参数
  - local baribales
    - 局部变量或者是本地变量
      - 是在函数内部定义的变量，每一次函数的运行都会产生一定的空间，这些变量在这个产生的空间内生存
      - 也叫自动变量，因为生存期和作用域是自动的
      - 每一个变量都有自己的生存区域，如果在自己所在之外有定义过这个变量，那么在这一个块内的变量根据在这一个块内定义的来算
    - 所以建议在编写原型的时候，一定要把参数的类型写上去，如果没有类型，那么使用void，不然编译器会去各种自己解释，有可能会出现一些问题
    - 在函数中，参数表中的（a，b）中的，不是运算符，但是参数表写成（（a，b））的格式，那么其中的，就是运算符了
    - 返回值是0，表示事情进展顺利，一切正常；当返回值是任何非0的数字，那么表示又不对劲的地方
    - bash是BA shell

### 数组

- 型式 数组名称 [数组数量]

- 数组一旦创建，那么无法再次被改变大小

  - 数组在内存中是依次排开的
  - 赋值号左边的叫做左值，右边的叫做右值
  - 数组不是c语言独有的，在fortran里面也有，但是fortran不是从0开始的，因为从0开始标号对于 编译器会简单很多，之后的c-like语言都是数组从0开始标号的

- 数组的初始化

  - 可以使用 

    ```c
    array_init[可以没有数字]={[1]=4,2,3,[12]=4}
    //如此初始化的数组是0，4，2，3，0，0，0，0，0，0，0，4
    ```

  - 对于数组大小的判定

    - 使用sizeof

      - 数组大小

        ```c
        数组大小=sizeof(array)/sizeof(array[0]);
        ```

      - 数组本身不能够被直接复制过去，本质是一个const的东西

      - 在数组初始化的时候，比如int array_ini={1，2，3，}，在最后可以加上一个逗号，可以拿来装一装，这是一个70/80年代一个口耳相传的传统，也方便了后面的人加入东西。这最后加的一个逗号不会影响编译

    - 注意在数组传入函数的时候，往往需要再定义一个用于表示数组长度的变量，因为在函数中是无法使用sizeof来判定出数组的长度的，需要在函数外判断出数组的长度并作为参数传入函数中（和指针有关）

      - 因为传进去之后这一个数组变成了一个指针，所以大小在函数中变成了一个指针的大小，数组变量是特殊的指针，数组本身表达地址
      - 数组变量是const指针，不能够被赋值，这也是数组之间是不能赋值的原因
      - int a[]=int * const a;
        - 关于const和*的关系，const在\*前面表示变量值不能被更改，在之后表示指针指向的值不能被更改
        - 使用const指针能够以比较少的字节数传递值给函数，也能避免函数对外面变量的修改（即const *，非\*const）

    - 把一个数组的所有元素交给另一个数组，只能够使用遍历的方法

    - 注意：在二维数组或者多维数组中，使用array[i，j]，这么做i，j会构成一个运算表达式，得到结果j，最后结果和array[j]一致

      - 多维数组的行可以不给出，编译器会自动填充，但是列一定得给出
        - 注意：多维数组只能第一个方括号是空的

### 地址与指针

- 取地址运算&
  - 获取变量的地址，必须作用在变量上，用于取出变量的地址
  - 输出地址使用%p更准确，虽然%x也会输出同样的16进制，但是会得到一个warning
  - 取地址必须是取一个确切的地址

- 指针*

  - 保存地址的变量，取出地址上的量，就是保存地址的变量
  - 注意：int* p，q；是把星号加给了p不是给q，本质是p指针和q的int类型变量；不管星号是靠近int还是靠近p，意思是一样的
    - 是\*p是一个int，不是int* 是p
    - p应该是之后用来指向一个变量的指针，值是一个地址
    - *p是这个地址取出的值
  - 指针变量存有的是实际值的变量的地址
  - 向函数内传入指针，就能够在函数内控制外面的变量
  - *是一个单目运算符，用来访问指针的值所表示的地址上的变量

- 关于左值

  - 是值不是变量
  - 因为出现在赋值号左边的不是变量，是表达式计算的结果，是值

- 什么时候非用指针

  - 

    ```c
    //在函数的时候交换两个值
    引用的时候：swap（&a，&b）；
    定义的时候：swap（*a，*b）；
    
    ```

- 指针运算

  - 指针+1，是指向（指针原地址+1*指针指向的元素大小）的地址
  - 可以使用+，+=，-，-=，不能乘除

- 指针的比较

  - 就是地址大小的比较

- *p++

  - ++优先级高，但是 是用完p之后进行+一个模具大小的内存空间

- 0地址

  - 是一个不能随便碰的地址，所以指针不应该具有0值
    - 但是可以使用0地址来表示返回的指针是无效的
    - 或者指针没有被真正的初始化

- NULL（必须全部大写，小写不管用）

  - 是一个被预定义的符号，表示0地址，因为有的编译器不愿意用0来表示0地址
  - 想要使用0地址的时候，建议不使用0，而是使用NULL

- 指针的类型

  - 无论指向什么类型，所有的指针的大小都是一样的，因为都是地址
    - 但是只想不同类型的指针是不能直接互相赋值的，是为了避免用错指针

- 指针的类型转换 

  - 对于小白没什么意义，但是很多时候不得不做这个

  - void*表示不知道指向什么东西的指针

    - 计算的时候和char*相同，但是不相通

  - 指针也可以转换类型

    - ```c
      int *p = &i;
      void *q = (void*) p;
      ```

- 指针的用途

  - 传入较大的数据的时候用作参数

  - 传入数组之后对数组进行操作

  - 函数需要返回不止一个结果的时候

  - 需要用函数修改不止一个变量

  - 动态申请内存

    - 在C99之前有ANSI标准，不支持以变量的形式输入数组个数

    - 使用malloc需要使用头文件stdlib.h

    - 返回的是void*，所以大多时候需要强制类型转换

    - ```c
      c99: int array_a[10];
      ANSI / C99: array_a = (int*)malloc(number*sizeof(int))
      ```

      - 之后拿array_a当数组用就可以 
      - 一旦用malloc得到了一块空间交给了array_a，之后对array_a的操作完全可以当作数组用，本质就是一个数组
        - 这就是使用malloc数组分配可变的空间分配

    - 还内存

      - ```c
        free(array_a);
        ```

      - 注意：只能通过还申请来的空间的首地址来还地址

    - 向malloc申请的空间的大小是以字节为单位的，返回的结果是void*，需要类型转换为自己需要的类型

      - malloc只是用来要空间
      - 如果空间被用完了，malloc申请失败会返回0或者NULL
      - 系统最大给的空间根据不同的操作系统是不一样的  

    - free

      - 如果free（NULL）能够运行，只是它什么都不做
      - free（NULL）对于写指针程序是一个好习惯，因为一个指针被定义的时候为NULL，到时候释放的时候释放的其实就是NULL，由于某些原因没有malloc，或者malloc得到一个失败的结果，指针就是NULL，所以为了配合这个好习惯，所以free（0）是不会出错的，free（1）之类的会是错误的

    - 常见的问题

      - 申请了没有free会导致长时间运行内存逐渐下降
        - 对于小程序是无所谓的，malloc即使没有free，当程序运行结束的时候，os会释放这个程序使用过的所有内存
        - 这是一个坏习惯，程序申请的内存是有限的，写大程序会出大问题
        - 对于新手来说，是忘记free；对于不够高的高手来说，是找不到合适的时机和地方做free这件事情，是代码结构问题
      - free过的内存再free了一次，如果地址变过了，直接去free会报错
      - 解决方法
        - 牢牢记住free，有一个malloc就写一个free牢牢配对
        - 对程序的整体架构有良好的设计，保证程序有良好的时机去free
        - 有经验，多阅读别人的代码，写自己的代码，在实践中失败并且总结经验
